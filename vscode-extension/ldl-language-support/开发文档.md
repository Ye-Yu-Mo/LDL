# LDL Language Support å¼€å‘æ–‡æ¡£

## ğŸ“– é¡¹ç›®æ¦‚è¿°

LDL Language Support æ˜¯ä¸€ä¸ªä¸º Learning Domain Language (LDL) æä¾›çš„ VS Code æ’ä»¶ã€‚LDL æ˜¯ä¸€ç§ä¸“é—¨ç”¨äºæè¿°å­¦ä¹ æ–¹æ³•è®ºå’ŒçŸ¥è¯†æ¡†æ¶çš„é¢†åŸŸç‰¹å®šè¯­è¨€ (DSL)ã€‚

### ğŸ¯ é¡¹ç›®ç›®æ ‡
- ä¸º LDL æä¾›å®Œæ•´çš„ IDE æ”¯æŒ
- æ”¯æŒæ–¹æ³•è®ºçš„æ ‡ç­¾åŒ–ç®¡ç†å’Œåˆ†ç±»
- æä¾›æ™ºèƒ½å¯¼èˆªå’Œæœç´¢åŠŸèƒ½
- ä¸ºå­¦ä¹ æ–¹æ³•è®ºçš„æè¿°å’Œç®¡ç†æä¾›å·¥å…·æ”¯æŒ

### ğŸ—ï¸ æŠ€æœ¯æ¶æ„
- **è¯­è¨€**: TypeScript
- **æ¡†æ¶**: VS Code Extension API
- **æ„å»ºå·¥å…·**: TypeScript Compiler
- **è¯­æ³•é«˜äº®**: TextMate Grammar (JSON)

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
ldl-language-support/
â”œâ”€â”€ src/                          # TypeScript æºç 
â”‚   â”œâ”€â”€ extension.ts             # æ’ä»¶å…¥å£ç‚¹
â”‚   â”œâ”€â”€ parser.ts                # LDL è¯­è¨€è§£æå™¨
â”‚   â”œâ”€â”€ definitionProvider.ts   # å®šä¹‰è·³è½¬æä¾›å™¨
â”‚   â”œâ”€â”€ documentSymbolProvider.ts # æ–‡æ¡£ç¬¦å·æä¾›å™¨
â”‚   â””â”€â”€ workspaceSymbolProvider.ts # å·¥ä½œåŒºç¬¦å·æä¾›å™¨
â”œâ”€â”€ out/                         # ç¼–è¯‘è¾“å‡ºç›®å½•
â”œâ”€â”€ syntaxes/                    # è¯­æ³•é«˜äº®å®šä¹‰
â”‚   â””â”€â”€ ldl.tmLanguage.json     # TextMate è¯­æ³•æ–‡ä»¶
â”œâ”€â”€ examples/                    # ç¤ºä¾‹ LDL æ–‡ä»¶
â”‚   â””â”€â”€ test.ldl                # æµ‹è¯•ç”¨ä¾‹
â”œâ”€â”€ docs/                        # æ–‡æ¡£ç›®å½•
â”‚   â”œâ”€â”€ ä½¿ç”¨æ–‡æ¡£.md
â”‚   â”œâ”€â”€ LDLå…³é”®å­—å‚è€ƒ.md
â”‚   â””â”€â”€ LDLå˜é‡ç±»å‹å‚è€ƒ.md
â”œâ”€â”€ package.json                 # æ’ä»¶é…ç½®å’Œä¾èµ–
â”œâ”€â”€ tsconfig.json               # TypeScript é…ç½®
â”œâ”€â”€ language-configuration.json  # è¯­è¨€é…ç½®
â””â”€â”€ README.md                   # é¡¹ç›®è¯´æ˜
```

---

## ğŸ› ï¸ æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 1. **LDL Parser (`src/parser.ts`)**

#### åŠŸèƒ½èŒè´£
- è§£æ LDL æ–‡æ¡£å¹¶æå–ç¬¦å·ä¿¡æ¯
- æ”¯æŒå‡½æ•°ã€pipelineã€ç±»ã€å¸¸é‡ã€å®ç­‰çš„è§£æ
- å¤„ç† `@label` è£…é¥°å™¨å’Œæ–‡æ¡£æ³¨é‡Š
- ç»´æŠ¤ç¬¦å·ç´¢å¼•å’Œæ ‡ç­¾ç´¢å¼•

#### æ ¸å¿ƒæ¥å£
```typescript
export interface LDLSymbol {
    name: string;
    position: vscode.Position;
    type: 'function' | 'pipeline' | 'type_alias' | 'macro' | 'constant' | 'class' | 'method';
    version?: string;           // ç‰ˆæœ¬åŒ–å‡½æ•°æ”¯æŒ
    labels?: string[];          // æ ‡ç­¾åˆ—è¡¨
    documentation?: string;     // æ–‡æ¡£æ³¨é‡Š
    className?: string;         // æ‰€å±ç±»å
    parentClass?: string;       // çˆ¶ç±»å
    isStatic?: boolean;         // æ˜¯å¦é™æ€æ–¹æ³•
}
```

#### å…³é”®æ–¹æ³•
```typescript
export class LDLParser {
    // è§£ææ•´ä¸ªæ–‡æ¡£
    parseDocument(document: vscode.TextDocument): void

    // æŸ¥æ‰¾ç¬¦å·ï¼ˆæ”¯æŒç‰ˆæœ¬å’Œç±»åï¼‰
    findSymbol(name: string, version?: string, className?: string): LDLSymbol | undefined
    findAllSymbols(name: string, version?: string, className?: string): LDLSymbol[]

    // æ ‡ç­¾ç›¸å…³æŸ¥è¯¢
    findSymbolsByLabel(label: string): LDLSymbol[]
    getAllLabels(): string[]
    getSymbolsByLabels(): Map<string, LDLSymbol[]>
}
```

#### è§£ææµç¨‹
1. **æ–‡æ¡£è§£æ**: `parseDocument()` â†’ æ¸…ç†ç¼“å­˜ â†’ è°ƒç”¨å„ä¸ªè§£æå™¨
2. **ç¬¦å·æå–**: ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å„ç§è¯­æ³•ç»“æ„
3. **æ ‡ç­¾è§£æ**: `parseLabelsAndDocumentation()` â†’ å‘å‰æŸ¥æ‰¾è£…é¥°å™¨
4. **ç´¢å¼•æ„å»º**: åŒæ—¶ç»´æŠ¤åç§°ç´¢å¼•å’Œæ ‡ç­¾ç´¢å¼•

---

### 2. **Definition Provider (`src/definitionProvider.ts`)**

#### åŠŸèƒ½èŒè´£
- æä¾› "è·³è½¬åˆ°å®šä¹‰" åŠŸèƒ½ (`Ctrl+Click`, `F12`)
- æ”¯æŒå‡½æ•°é‡è½½çš„å¤šå®šä¹‰é€‰æ‹©
- ç‰ˆæœ¬åŒ–å‡½æ•°çš„æ™ºèƒ½è·³è½¬

#### å®ç°é€»è¾‘
```typescript
export class LDLDefinitionProvider implements vscode.DefinitionProvider {
    provideDefinition(
        document: vscode.TextDocument,
        position: vscode.Position,
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Definition> {
        // 1. è§£ææ–‡æ¡£
        this.parser.parseDocument(document);

        // 2. è·å–å…‰æ ‡ä¸‹çš„è¯
        const word = document.getText(wordRange);

        // 3. æ£€æµ‹ä¸Šä¸‹æ–‡ï¼ˆå‡½æ•°è°ƒç”¨ vs ç±»å‹å¼•ç”¨ï¼‰
        if (isFunctionCall) {
            // 4a. æå–ç‰ˆæœ¬ä¿¡æ¯
            const version = extractVersion(lineText);
            // 4b. æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„å®šä¹‰
            const symbols = this.parser.findAllSymbols(word, version);
            // 4c. è¿”å›å•ä¸ªæˆ–å¤šä¸ªå®šä¹‰
            return createLocationArray(symbols);
        } else {
            // 4d. å¤„ç†ç±»å‹ã€å¸¸é‡ç­‰çš„è·³è½¬
        }
    }
}
```

#### ç‰¹æ®Šå¤„ç†
- **ç‰ˆæœ¬æ£€æµ‹**: è¯†åˆ« `fn(version: "name")` è°ƒç”¨æ¨¡å¼
- **ç±»æ–¹æ³•**: æ”¯æŒ `Class.method()` è·³è½¬
- **å¤šå®šä¹‰**: è¿”å› `vscode.Location[]` è®©ç”¨æˆ·é€‰æ‹©

---

### 3. **Document Symbol Provider (`src/documentSymbolProvider.ts`)**

#### åŠŸèƒ½èŒè´£
- æ–‡æ¡£å¤§çº²æ˜¾ç¤º (`Ctrl+Shift+O`)
- æŒ‰æ ‡ç­¾åˆ†ç»„çš„ç¬¦å·å¯¼èˆª
- å±‚æ¬¡åŒ–çš„ç¬¦å·ç»“æ„å±•ç¤º

#### æ ¸å¿ƒåŠŸèƒ½
```typescript
export class LDLDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    provideDocumentSymbols(document: vscode.TextDocument): vscode.DocumentSymbol[] {
        // 1. è§£ææ–‡æ¡£è·å–æ‰€æœ‰ç¬¦å·
        this.parser.parseDocument(document);

        // 2. æŒ‰æ ‡ç­¾åˆ†ç»„
        const symbolsByLabels = this.parser.getSymbolsByLabels();

        // 3. åˆ›å»ºæ ‡ç­¾æ–‡ä»¶å¤¹èŠ‚ç‚¹
        for (const [label, symbols] of symbolsByLabels) {
            const labelNode = new vscode.DocumentSymbol(
                `ğŸ“ ${label}`,
                `${symbols.length} items`,
                vscode.SymbolKind.Namespace,
                range, range
            );

            // 4. æ·»åŠ å­ç¬¦å·
            for (const symbol of symbols) {
                labelNode.children.push(createDocumentSymbol(symbol));
            }
        }

        // 5. å¤„ç†æ— æ ‡ç­¾ç¬¦å·
        const unlabeledSymbols = getUnlabeledSymbols();
        // ...
    }
}
```

#### æ˜¾ç¤ºæ•ˆæœ
```
ğŸ“ philosophy
  â”œâ”€â”€ ğŸ”§ dialectical_materialism (function) - è¾©è¯å”¯ç‰©ä¸»ä¹‰åˆ†ææ–¹æ³•
  â””â”€â”€ ğŸ”§ practice_cognition (function) - å®è·µè®¤è¯†è®ºæ–¹æ³•
ğŸ“ learning
  â”œâ”€â”€ ğŸ”§ SQ3R (function) - ç³»ç»ŸåŒ–é˜…è¯»æ–¹æ³•
  â””â”€â”€ âš¡ comprehensive_learning (pipeline) - å®Œæ•´å­¦ä¹ æµç¨‹
ğŸ“„ Unlabeled
  â””â”€â”€ ğŸ”§ helper_function (function)
```

---

### 4. **Workspace Symbol Provider (`src/workspaceSymbolProvider.ts`)**

#### åŠŸèƒ½èŒè´£
- å…¨å±€ç¬¦å·æœç´¢ (`Ctrl+T`)
- æ”¯æŒå¤šç§æœç´¢æ¨¡å¼
- å·¥ä½œåŒºèŒƒå›´çš„ç¬¦å·å‘ç°

#### æœç´¢æ¨¡å¼
```typescript
class LDLWorkspaceSymbolProvider {
    private filterSymbols(parser: LDLParser, query: string): LDLSymbol[] {
        const queryLower = query.toLowerCase();

        // 1. æ ‡ç­¾æœç´¢: @label:name æˆ– label:name
        const labelMatch = query.match(/^@?label:\s*(.+)$/i);
        if (labelMatch) {
            return parser.findSymbolsByLabel(labelMatch[1]);
        }

        // 2. ç±»å‹æœç´¢: type:function æˆ– t:fn
        const typeMatch = query.match(/^t(?:ype)?:\s*(.+)$/i);
        if (typeMatch) {
            return filterByType(allSymbols, typeMatch[1]);
        }

        // 3. åç§°/æ–‡æ¡£æœç´¢
        return fuzzySearch(allSymbols, queryLower);
    }
}
```

#### ç¼“å­˜æœºåˆ¶
- æ–‡æ¡£è§£æç»“æœç¼“å­˜
- åŸºäºæ–‡ä»¶ä¿®æ”¹æ—¶é—´çš„æ™ºèƒ½å¤±æ•ˆ
- å¤šæ–‡ä»¶æœç´¢æ€§èƒ½ä¼˜åŒ–

---

### 5. **è¯­æ³•é«˜äº® (`syntaxes/ldl.tmLanguage.json`)**

#### TextMate Grammar ç»“æ„
```json
{
    "name": "LDL",
    "scopeName": "source.ldl",
    "patterns": [
        { "include": "#comments" },
        { "include": "#keywords" },
        { "include": "#strings" },
        { "include": "#decorators" },
        { "include": "#functions" },
        { "include": "#function_calls" },
        // ...
    ],
    "repository": {
        "keywords": {
            "patterns": [
                {
                    "name": "keyword.control.ldl",
                    "match": "\\b(fn|pipeline|class|using|macro|const)\\b"
                }
            ]
        }
        // ...
    }
}
```

#### é«˜äº®ç‰¹æ€§
- **å…³é”®å­—**: è¯­è¨€æ ¸å¿ƒå…³é”®å­—
- **è£…é¥°å™¨**: `@label("name")` ç‰¹æ®Šé«˜äº®
- **å‡½æ•°è°ƒç”¨**: å‘½åå‚æ•°å’Œç‰ˆæœ¬ä¿¡æ¯
- **ç±»å‹æ ‡æ³¨**: å†…ç½®å’Œè‡ªå®šä¹‰ç±»å‹
- **æ³¨é‡Š**: æ”¯æŒæ–‡æ¡£æ³¨é‡Š `///`

---

## ğŸ”§ å¼€å‘ç¯å¢ƒæ­å»º

### å‰ç½®è¦æ±‚
```bash
# Node.js ç‰ˆæœ¬è¦æ±‚
node --version  # >= 16.0.0
npm --version   # >= 8.0.0

# VS Code ç‰ˆæœ¬è¦æ±‚
# VS Code >= 1.60.0
```

### é¡¹ç›®åˆå§‹åŒ–
```bash
# 1. å…‹éš†é¡¹ç›®
git clone <repository-url>
cd ldl-language-support

# 2. å®‰è£…ä¾èµ–
npm install

# 3. ç¼–è¯‘é¡¹ç›®
npm run compile

# 4. å¯åŠ¨å¼€å‘æ¨¡å¼
npm run watch  # ç›‘å¬æ–‡ä»¶å˜åŒ–è‡ªåŠ¨ç¼–è¯‘
```

### å¼€å‘è°ƒè¯•
```bash
# æ–¹å¼1: VS Code è°ƒè¯•
# æŒ‰ F5 å¯åŠ¨è°ƒè¯•çª—å£

# æ–¹å¼2: æ‰‹åŠ¨å¯åŠ¨
code --extensionDevelopmentPath=. --new-window
```

---

## ğŸ“ ä»£ç è§„èŒƒ

### TypeScript ç¼–ç è§„èŒƒ

#### 1. å‘½åçº¦å®š
```typescript
// âœ… ç±»å: PascalCase
class LDLDefinitionProvider { }

// âœ… æ–¹æ³•å: camelCase
provideDefinition() { }

// âœ… å˜é‡å: camelCase
const symbolPosition = document.positionAt(index);

// âœ… å¸¸é‡: UPPER_SNAKE_CASE
const MAX_SEARCH_RESULTS = 100;

// âœ… æ¥å£: PascalCase with I prefix (å¯é€‰)
interface LDLSymbol { }
```

#### 2. ç±»å‹æ ‡æ³¨
```typescript
// âœ… æ˜¾å¼ç±»å‹æ ‡æ³¨
function parseDocument(document: vscode.TextDocument): void {
    const symbols: Map<string, LDLSymbol[]> = new Map();
    const text: string = document.getText();
}

// âœ… è¿”å›ç±»å‹æ ‡æ³¨
function findSymbol(name: string): LDLSymbol | undefined {
    return this.symbols.get(name)?.[0];
}
```

#### 3. é”™è¯¯å¤„ç†
```typescript
// âœ… é€‚å½“çš„é”™è¯¯å¤„ç†
try {
    const document = await vscode.workspace.openTextDocument(uri);
    const parser = await this.getParserForDocument(document);
    return parser.getAllSymbols();
} catch (error) {
    console.error(`Error parsing ${uri.toString()}:`, error);
    return [];
}
```

### ä»£ç ç»„ç»‡åŸåˆ™

#### 1. å•ä¸€èŒè´£
```typescript
// âœ… æ¯ä¸ªç±»ä¸“æ³¨ä¸€ä¸ªåŠŸèƒ½
class LDLParser {
    // åªè´Ÿè´£è§£æLDLè¯­æ³•
}

class LDLDefinitionProvider {
    // åªè´Ÿè´£å®šä¹‰è·³è½¬åŠŸèƒ½
}
```

#### 2. ä¾èµ–æ³¨å…¥
```typescript
// âœ… æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–
class LDLDefinitionProvider {
    constructor(private parser: LDLParser) {}
}
```

#### 3. æ¥å£éš”ç¦»
```typescript
// âœ… å®šä¹‰æ¸…æ™°çš„æ¥å£
interface SymbolProvider {
    findSymbol(name: string): LDLSymbol | undefined;
    getAllSymbols(): LDLSymbol[];
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•ç»“æ„
```typescript
// test/parser.test.ts
describe('LDLParser', () => {
    let parser: LDLParser;

    beforeEach(() => {
        parser = new LDLParser();
    });

    describe('parseDocument', () => {
        it('should parse function definitions', () => {
            const document = createMockDocument(`
                fn test_function() -> Steps {
                    return result
                }
            `);

            parser.parseDocument(document);
            const symbols = parser.getAllSymbols();

            expect(symbols).toHaveLength(1);
            expect(symbols[0].name).toBe('test_function');
            expect(symbols[0].type).toBe('function');
        });

        it('should parse labels correctly', () => {
            const document = createMockDocument(`
                @label("test")
                fn labeled_function() -> Steps {
                    return result
                }
            `);

            parser.parseDocument(document);
            const symbols = parser.findSymbolsByLabel('test');

            expect(symbols).toHaveLength(1);
            expect(symbols[0].name).toBe('labeled_function');
        });
    });
});
```

### é›†æˆæµ‹è¯•
```typescript
// test/integration.test.ts
describe('Extension Integration', () => {
    it('should provide correct definitions', async () => {
        const document = await vscode.workspace.openTextDocument(testFileUri);
        const position = new vscode.Position(10, 5);

        const definitions = await vscode.commands.executeCommand(
            'vscode.executeDefinitionProvider',
            document.uri,
            position
        );

        expect(definitions).toBeDefined();
        expect(definitions.length).toBeGreaterThan(0);
    });
});
```

### æµ‹è¯•è¿è¡Œ
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
npm test

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
npm test -- --grep "LDLParser"

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
npm run test:coverage
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. è§£æå™¨ä¼˜åŒ–

#### ç¼“å­˜ç­–ç•¥
```typescript
class LDLParser {
    private documentCache = new Map<string, {
        version: number;
        symbols: LDLSymbol[];
        lastModified: number;
    }>();

    parseDocument(document: vscode.TextDocument): void {
        const uri = document.uri.toString();
        const version = document.version;

        // æ£€æŸ¥ç¼“å­˜
        const cached = this.documentCache.get(uri);
        if (cached && cached.version === version) {
            this.symbols = new Map(cached.symbols);
            return;
        }

        // é‡æ–°è§£æ
        this.actualParse(document);

        // æ›´æ–°ç¼“å­˜
        this.documentCache.set(uri, {
            version,
            symbols: Array.from(this.symbols.entries()),
            lastModified: Date.now()
        });
    }
}
```

#### æƒ°æ€§åŠ è½½
```typescript
class LDLWorkspaceSymbolProvider {
    private symbolCache = new Map<string, LDLSymbol[]>();

    async provideWorkspaceSymbols(query: string): Promise<vscode.SymbolInformation[]> {
        // åªè§£ææŸ¥è¯¢ç›¸å…³çš„æ–‡ä»¶
        const relevantFiles = await this.findRelevantFiles(query);

        for (const file of relevantFiles) {
            if (!this.symbolCache.has(file.toString())) {
                await this.parseFile(file);
            }
        }

        return this.filterAndFormat(query);
    }
}
```

### 2. å†…å­˜ç®¡ç†

#### å®šæœŸæ¸…ç†
```typescript
class ExtensionManager {
    private cleanupTimer?: NodeJS.Timeout;

    activate() {
        // æ¯30åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡ç¼“å­˜
        this.cleanupTimer = setInterval(() => {
            this.cleanupOldCaches();
        }, 30 * 60 * 1000);
    }

    private cleanupOldCaches(): void {
        const now = Date.now();
        const maxAge = 60 * 60 * 1000; // 1å°æ—¶

        for (const [uri, cache] of this.documentCache) {
            if (now - cache.lastModified > maxAge) {
                this.documentCache.delete(uri);
            }
        }
    }
}
```

### 3. æœç´¢ä¼˜åŒ–

#### ç´¢å¼•æ„å»º
```typescript
class SearchIndex {
    private nameIndex = new Map<string, LDLSymbol[]>();
    private labelIndex = new Map<string, LDLSymbol[]>();
    private fuzzyIndex: FuzzySearch<LDLSymbol>;

    buildIndex(symbols: LDLSymbol[]): void {
        // æ„å»ºåç§°ç´¢å¼•
        for (const symbol of symbols) {
            this.addToIndex(this.nameIndex, symbol.name, symbol);

            // æ„å»ºæ ‡ç­¾ç´¢å¼•
            if (symbol.labels) {
                for (const label of symbol.labels) {
                    this.addToIndex(this.labelIndex, label, symbol);
                }
            }
        }

        // æ„å»ºæ¨¡ç³Šæœç´¢ç´¢å¼•
        this.fuzzyIndex = new FuzzySearch(symbols, {
            keys: ['name', 'documentation', 'labels']
        });
    }
}
```

---

## ğŸš€ éƒ¨ç½²å’Œå‘å¸ƒ

### æœ¬åœ°æ‰“åŒ…
```bash
# 1. å®‰è£… vsce å·¥å…·
npm install -g vsce

# 2. æ‰“åŒ…æ’ä»¶
vsce package

# 3. ç”Ÿæˆ .vsix æ–‡ä»¶
# è¾“å‡º: ldl-language-support-0.1.0.vsix
```

### æœ¬åœ°æµ‹è¯•å®‰è£…
```bash
# å®‰è£…æœ¬åœ°æ’ä»¶
code --install-extension ldl-language-support-0.1.0.vsix

# å¸è½½æ’ä»¶
code --uninstall-extension ldl-language-support
```

### å‘å¸ƒåˆ°å¸‚åœº
```bash
# 1. ç™»å½•å‘å¸ƒè€…è´¦å·
vsce login <publisher-name>

# 2. å‘å¸ƒæ’ä»¶
vsce publish

# 3. å‘å¸ƒç‰¹å®šç‰ˆæœ¬
vsce publish 1.0.1
```

### ç‰ˆæœ¬ç®¡ç†
```json
// package.json
{
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.60.0"
  }
}
```

#### è¯­ä¹‰åŒ–ç‰ˆæœ¬
- **0.x.y**: å¼€å‘ç‰ˆæœ¬
- **1.0.0**: é¦–ä¸ªç¨³å®šç‰ˆæœ¬
- **1.x.0**: æ–°åŠŸèƒ½ç‰ˆæœ¬
- **1.0.x**: é—®é¢˜ä¿®å¤ç‰ˆæœ¬

---

## ğŸ”® æœªæ¥è§„åˆ’

### Phase 1: æ ¸å¿ƒåŠŸèƒ½å®Œå–„
- [ ] è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½
- [ ] æ‚¬åœä¿¡æ¯æ˜¾ç¤º
- [ ] é”™è¯¯æ£€æŸ¥å’Œè¯Šæ–­
- [ ] ä»£ç ç‰‡æ®µæ”¯æŒ

### Phase 2: å¯è§†åŒ–å¢å¼º
- [ ] æ–¹æ³•è®ºæµç¨‹å›¾ç”Ÿæˆ
- [ ] æ ‡ç­¾å…³ç³»ç½‘ç»œå›¾
- [ ] ç»Ÿè®¡åˆ†æé¢æ¿
- [ ] æ–‡æ¡£å¯¼å‡ºåŠŸèƒ½

### Phase 3: åä½œå’Œé›†æˆ
- [ ] Git é›†æˆä¼˜åŒ–
- [ ] å›¢é˜Ÿåä½œåŠŸèƒ½
- [ ] å¤–éƒ¨å·¥å…·é›†æˆ
- [ ] API æ¥å£å¼€æ”¾

### Phase 4: AI å¢å¼º
- [ ] æ™ºèƒ½æ–¹æ³•è®ºæ¨è
- [ ] è‡ªç„¶è¯­è¨€æŸ¥è¯¢
- [ ] è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ
- [ ] ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„

---

## ğŸ“ è´¡çŒ®æŒ‡å—

### æäº¤è§„èŒƒ
```bash
# æäº¤ä¿¡æ¯æ ¼å¼
<type>(<scope>): <description>

# ä¾‹å­
feat(parser): add support for nested function calls
fix(syntax): correct highlighting for version parameters
docs(readme): update installation instructions
```

### å¼€å‘å·¥ä½œæµ
1. **Fork é¡¹ç›®** â†’ åˆ›å»ºä¸ªäººåˆ†æ”¯
2. **åŠŸèƒ½å¼€å‘** â†’ åœ¨ feature åˆ†æ”¯å¼€å‘
3. **æµ‹è¯•éªŒè¯** â†’ ç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡
4. **æäº¤ PR** â†’ è¯¦ç»†æè¿°å˜æ›´å†…å®¹
5. **ä»£ç å®¡æŸ¥** â†’ å“åº”å®¡æŸ¥æ„è§
6. **åˆå¹¶ä¸»åˆ†æ”¯** â†’ åŠŸèƒ½é›†æˆ

### é—®é¢˜æŠ¥å‘Š
ä½¿ç”¨ GitHub Issues æ¨¡æ¿ï¼š
- **Bug æŠ¥å‘Š**: è¯¦ç»†é‡ç°æ­¥éª¤
- **åŠŸèƒ½è¯·æ±‚**: ä½¿ç”¨åœºæ™¯å’ŒæœŸæœ›è¡Œä¸º
- **æ–‡æ¡£æ”¹è¿›**: å…·ä½“çš„æ”¹è¿›å»ºè®®

---

## ğŸ“š ç›¸å…³èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [VS Code Extension API](https://code.visualstudio.com/api)
- [TextMate Grammar Guide](https://macromates.com/manual/en/language_grammars)
- [Language Server Protocol](https://microsoft.github.io/language-server-protocol/)

### å¼€å‘å·¥å…·
- [VS Code Extension Generator](https://github.com/Microsoft/vscode-generator-code)
- [Extension Test Runner](https://github.com/microsoft/vscode-test)
- [VSCE Publishing Tool](https://github.com/microsoft/vscode-vsce)

### å‚è€ƒé¡¹ç›®
- [TypeScript Extension](https://github.com/microsoft/TypeScript)
- [Python Extension](https://github.com/microsoft/vscode-python)
- [Markdown Extension](https://github.com/microsoft/vscode-markdown-tm-grammar)

---

*æœ€åæ›´æ–°: 2024å¹´9æœˆ*
*ç»´æŠ¤è€…: LDL å¼€å‘å›¢é˜Ÿ*